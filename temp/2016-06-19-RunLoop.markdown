---
layout: post
title:  "RunLoop"
date:   2016-06-13 01:23:32
categories: iOS高级
---

Runloop
=======

Runloop 是什么？Runloop 还是比较顾名思义的一个东西，说白了就是一种循环，只不过它这种循环比较高级。一般的 while 循环会导致 CPU 进入忙等待状态，而 Runloop 则是一种“闲”等待，这部分可以类比 Linux 下的 epoll。当没有事件时，Runloop 会进入休眠状态，有事件发生时， Runloop 会去找对应的 Handler 处理事件。Runloop 可以让线程在需要做事的时候忙起来，不需要的话就让线程休眠。


## Runloop 与线程

在刚刚接触iOS开发的时候，我们在Xcode的帮助下生成了第一个工程。工程里会包含一个 `main.m` 的文件，默认的代码大致如下：
![main.m](http://ooo.0o0.ooo/2016/06/19/576696159687a.png)
当我们的程序启动时，以上代码会被调用，主线程也随之开始运行。Run Loop做为主线程的一部分也同时被启动。
Runloop 和线程是绑定在一起的。每个线程（包括主线程）都有一个对应的 Runloop 对象。我们并不能自己创建 Runloop 对象，但是可以获取到系统提供的 Runloop 对象。

主线程的 Runloop 会在应用启动的时候完成启动，其他线程的 Runloop 默认并不会启动，需要我们手动启动。

![Runloop](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg)

Run Loop本质和它的意思一样是运行着的循环，更确切的说是线程中的循环。它用来接受循环中的事件和安排线程工作，并在没有工作时，让线程进入睡眠状态。
图中展现了 Runloop 在线程中的作用：从 input source 和 timer source 接受事件，然后在线程中处理事件。
## Runloop Mode

在监视与被监视中，Runloop 要处理的事情还挺复杂的。为了让 Runloop 能专心处理自己关心的那部分事情，引入了 Runloop Mode 概念。

![Runloop Mode](http://cc.cocimg.com/api/uploads/20150528/1432798883604537.png)

如图所示，Runloop Mode 实际上是 Source，Timer 和 Observer 的集合，不同的 Mode 把不同组的 Source，Timer 和 Observer 隔绝开来。Runloop 在某个时刻只能跑在一个 Mode 下，处理这一个 Mode 当中的 Source，Timer 和 Observer。

下面列出iOS下一些已经定义的Run Loop Modes:

1. NSDefaultRunLoopMode: 大多数工作中默认的运行方式。
2. NSConnectionReplyMode: 使用这个Mode去监听NSConnection对象的状态，我们很少需要自己使用这个Mode。
3. NSModalPanelRunLoopMode: 使用这个Mode在Model Panel情况下去区分事件(OS X开发中会遇到)。
4. UITrackingRunLoopMode: 使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）。
5. GSEventReceiveRunLoopMode: 用来接受系统事件，内部的Run Loop Mode。
6. NSRunLoopCommonModes: 这是一个伪模式，其为一组run loop mode的集合。如果将Input source加入此模式，意味着关联Input source到Common Modes中包含的所有模式下。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、UITrackingRunLoopMode.可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义mode。

iOS 中公开暴露出来的只有 NSDefaultRunLoopMode 和 NSRunLoopCommonModes。 NSRunLoopCommonModes 实际上是一个 Mode 的集合，默认包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode。


## Run Loop 事件队列

Run Loop本质是一个处理事件源的循环。我们对Run Loop的运行时具有控制权，如果当前没有时间发生，Run Loop会让当前线程进入睡眠模式，来减轻CPU压力。如果有事件发生，Run Loop就处理事件并通知相关的Observer。具体的顺序如下:
![](http://ooo.0o0.ooo/2016/06/19/57669cb45214b.png)

1. Run Loop进入的时候，会通知Observer
2. Timer即将被触发时，会通知Observer
3. 有其它非Port-Based Input Source即将被触发时，会通知Observer
4. 启动非Port-Based Input Source的事件源
5. 如果基于Port的Input Source事件源即将触发时，立即处理该事件，并跳转到9
6. 通知Observer当前线程进入睡眠状态
7. 将线程置入睡眠状态直到有以下事件发生：1. Port-Based Input Source被触发。2.Timer被触发。 3.Run Loop设置的时间已经超时。 4.Run Loop被显示唤醒。
8. 通知Observer线程将要被唤醒
9. 处理被触发的事件：1. 如果是用户自定义的Timer，处理Timer事件后重启Run Loop并直接进入步骤2。 2.如果线程被显示唤醒又没有超时，那么进入步骤2。 3.如果是其他Input Source事件源有事件发生，直接传递这个消息。
10. 通知Observer Run Loop结束，Run Loop退出。

基于非Timer的Input source事件被处理后，Run Loop在将要退出时发送通知。基于Timer source处理事件后不会退出Run Loop。

## 何时使用 Run Loop

我们应该只在创建辅助线程的时候，才显示的运行一个Run Loop。对于辅助线程，我们仍然需要判断是否需要启动Run Loop。比如我们使用一个线程去处理一个预先定义的长时间的任务，我们应当避免启动Run Loop。下面是官方Document提供的使用Run Loop的几个场景:

-	需要使用Port-Based Input Source或者Custom Input Source和其他线程通讯时
-	需要在线程中使用Timer
-	需要在线程中使用上文中提到的selector相关方法
- 需要让线程执行周期性的工作


## Run Loop开发中遇到的问题

NSTimer, NSURLConnection和NSStream默认运行在Default Mode下，UIScrollView在接收到用户交互事件时，主线程Run Loop会设置为UITrackingRunLoopMode下，这个时候NSTimer不能fire，NSURLConnection的数据也无法处理。

```
// 在UITableViewController中启动一个NSTimer，每隔0.5秒刷新Label上的text,刷新100次后暂停。

@interface TestTableViewController ()

@property (nonatomic, strong) UILabel *testLabel;
@property (nonatomic) NSInteger count;
@property (nonatomic, strong) NSTimer *testTimer;

@end

@implementation TestTableViewController

- (void)viewDidLoad {
    [super viewDidLoad];

    self.count = 0;

    self.testLabel = [[UILabel alloc] initWithFrame:CGRectMake(20, 100, 100, 50)];
    [self.view addSubview:self.testLabel];

    self.testTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self        selector:@selector(updateTestLabel) userInfo:nil repeats:YES];
}

- (void)updateTestLabel
{
    self.count ++;
    self.testLabel.text = [NSString stringWithFormat:@"%ld", self.count];
    if (self.count == 100) {
       [self.testTimer invalidate];
       self.testTimer = nil;
    }
}

@end

```

有如下两种解决方案：

- 第一种: 设置RunLoop Mode，例如NSTimer,我们指定它运行于 NSRunLoopCommonModes ，这是一个Mode的集合。注册到这个 Mode 下后，无论当前 runLoop 运行哪个 mode ，事件都能得到执行。
- 第二种: 另一种解决Timer的方法是，我们在另外一个线程执行和处理 Timer 事件，然后在主线程更新UI。


上述代码，在正常情况下Label可以刷新text，但是在用户拖动TableView时，label将不在更新，直到手指离开屏幕。 解决方法，一种是修改Timer运行的Run Loop模式，将其加入NSRunLoopCommonModes中。

```
/* self.testTimer = [NSTimer scheduledTimerWithTimeInterval:0.5 target:self         selector:@selector(updateTestLabel) userInfo:nil repeats:YES]; */

self.testTimer = [NSTimer timerWithTimeInterval:0.5 target:self selector:@selector(updateTestLabel) userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:self.testTimer forMode:NSRunLoopCommonModes];
```

### 释放问题
- NSTimer的构造方法会对传入的target对象强引用，直到这个timer对象invalidated。在使用时需要注意内存问题，根据需要，要在适当的地方调用invalidated方法。


- 运行一次的Timer源也可能导致Run Loop退出：一次的Timer在执行完之后会自己从Run Loop中删除，如果使用while来驱动Run Loop的话，下一次再运行Run Loop就可能导致退出，因为此时已经没有其他的源需要监控。


更多请参考：[Run Loop内部流程](http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-%5B%3F%5D-:shi-yao-shi-run-loop%3F/)

